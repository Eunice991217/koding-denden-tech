# 코딩을 지탱하는 기술

# 1장 효율적으로 언어 배우기
이 장에서는 앞으로 언어를 배울떄 학습하는 방법에 대해서 얘기해주고 있다.
비교를 통한 배움, 많은 언어에서 공통적으로 사용하고 있는 개념에 대해서 아는 것이 중요하며, 그 개념의 적용하는 것은 언어마다 규칙에 따라서 차이점이 존재하기에 비교를 통해서 학습하자.
역사를 통한 배움, 언어의 발전을 통해서 어떤 이유에서 나오게 되었는지 학습하면서 왜 탄생했는지 익힐 수 있다.

# 2장 프로그래밍 언어를 조감하다.

## ENIAC, 계산 귀찮지? 대신 해줄게
프로그래밍은 인간을 편하게 하기 위한 도구인데, 이는 첫 시작으로 계산을 편하게 하기 위해 ENIAC이라는 거대한 컴퓨터가 등장한다. ENIAC은 군용으로 개발된 컴퓨터였고, 계산능력은 탁월했다고 한다. 그런데 세팅하는 작업에 있어서 직접 케이블을 연결해야했기에
시간이 엄청나게 오래 걸리는 문제가 있었다.

 
 ## EDSAC, 변경하기 어려워? 세팅 해줄게
EDSAC에서는 케이블을 일일히 연결해 세팅하던 방식을 종이카드로 세팅과 입력값을 데이터로 표현하고 이를 입력하면, EDSAC이 데이터를 읽어들여 프로그램을 변경하는 작업을 한층 수월하게 해줬다.

## FORTRAN, 읽기 어려워? 코드해석 해줄게
FORTRAN의 등장으로 읽기 쉬운 코드를 만들기 위해서 발명되었다. 기계어로 코드를 짜는 방식이 아닌, 인간이 받아들이기 쉬운 코드로 작성하고 기계어로 변환함으로써 프로그래밍을 조금 더 편리하게 할 수 있도록 만들어줬다.

## 프로그래머로써의 3대 미덕
여기서 말하는 프로그래머의 3대 미덕으로, 나태, 조바심, 자만심이라는 키워드가 등장한다.
나태는 프로그래머로써 나태해지기 위해서는 구조화된 프로그래밍과 불필요한 코드를 줄이라는 의미를 가진다.
조바심은 컴퓨터가 느려질때에 대해서 컴퓨터에 대한 분노를 의미하여, 더 좋은 설계와 더 빠르게 작동하는 방법에 대해서 고민하라는 의미를 가진다.
자만심은 내 코드에 대한 자신감을 가지고 남부끄럽지않은 코드를 작성해야한다는 의미를 가지고 있다.

## 언어에 따른 편리함의 의미
여기서 말하는 편리함에는 언어의 목적을 의미하며, 다른 목적을 가진 언어끼리 비교하는 것은 무의미하다고 말하고 있다.
C++은 빠른 실행속도를 중시하는 언어고, Scheme은 언어 사양을 쉽게 파악할 수 있는 데 중점을 두고 있으며, Python은 코드를 쉽게 해석 할 수 있는데 중점을 두고 있다. PHP는 웹서비스를 쉽게 만드는 데에 중점을 두고 있다.
위와 같이 다양한 언어들이 추구하는 편리함이 다르기 때문에 목적이 다른 언어를 비교하는 것은 유익하지 못한 논쟁이다.


# 3장 문법
이 장에서는 솔직히 뭘 정리해야할지 모르겠다. 그냥 그렇구나하고 문법도 사람이 정한것이어서 다를수도 있구나정도로 받아들였다.

'1 더하기 2에 3을 곱한다'는 같은 처리여도, 언어에 따라서 표현 방법이 틀리다. 언어마다 차이가 생긴 것은 '어떤 문자열을 어떤 구문트리가 생기는 가'라는 규칙때문에 발생한 것이다. 이것이 문법이다.
FORTRAN은 이미 사람들이 정해놓은 규칙을 기반으로 프로그래밍으로 가져와 문법을 만들어 사람들의 사랑을 받게 되었고, 현재 우리가 사용하고 있는 언어는 FORTRAN 식의 '다가가기 쉬운 작성법'을 목표로 하고 있으며, 새로운 문법 규칙을 만드는 것은
기존에 있던 문법들과 충돌을 일으키지 않으면서 만들어야하기 때문에 어려운 일이라고 한다.


# 4장 처리 흐름 제어
구조화된 프로그래밍은 코드 구조를 알기 쉽게 하기 위해서 도입된 것이다.
이를 통해 우리는 코드를 흐름을 이해하는데 시간을 절약할 수 있게 되었다.

가정문과 반복문과 같은 흐름 제어문들이 없었을 시절 어셈블리어로 작성된 코드들을 보면 이 코드의 의미 해석하기 어려웠던 문제가 있다.
그래서 이런 흐름 제어문들이 나오게 된 것이고, if문과 while문을 쓰는 코드와 어셈블리어로 작성한 코드를 비교하면서 이런 구문들을 이용한 프로그래밍의 코드들이 이해하기 쉽다는 장점을 확인할 수 있다.


## while문과 for문
사실 둘의 기능은 똑같은데, while문은 선언문 조건식 증감식을 다른 위치에서 사용되고 있었고, 이를 한곳에 모아 관리함으로써 좀 더 이해하기 쉬운 코드를 만들기 위해 for문이 나오게 된 것이다.


# 5장 함수
함수는 이름만으로 코드의 기능을 이해하고 재사용하기 위해 필요로 하게 되었다.
이를 통해 코드를 전반적으로 이해할 수 있었고, 반복되는 코드들을 줄일 수 있었다.

## 돌아가라는 명령
if문 while문, for문이 전부 goto문으로 구현되어 있는 것을 배웠는데, 소스코드를 재사용하기에는 goto문 만으로는 역부족이었다.
점프 할 떄 '어디에서 점프해 왔는지'를 기억해두고, 나중에 '돌아가'라는 명령을 만나면 점프 명령 직후로 점프하게 하고 싶어서 함수를 사용하게 되었다.

## 내포구조를 다루는 방법
내부에 반복되는 구조를 가질 경우 함수의 강점이 나오게 된다. 즉, 재귀의 상황을 말하는데 이때 for문으로 처리해도 되지 않냐는 질문이 나올 수 있는데, 100중 for문을 만들 수 있는가?
그렇게 되면 반복된 코드들이 엄청 많아지고, 어떤 의미를 가지는지 해석하기 어려울 수 있는데 이 부분은 함수를 통해서 구현하면 코드를 간결하게 유지하면서 문제를 해결 할 수 있다.




# 느낀점
우리가 당연하게 사용하고 있던 것들에 대해서 생각해볼 수 있는 시간을 가질 수 있었다. 사실 코딩을 하면서 원하는대로 작동하지 않을떄 불만을 가질때가 많은 것 같은데, 이걸 옛날 방식으로 진공관의 케이블을 연결해서 작동시키려고했어봐라
그렇게 힘들게 만든 프로그램이 원하는대로 작동하지 않으면 얼마나 좌절하고 기계를 부셔버리고싶었겠는가.. 그래도 지금은 키보드만 뚝딱거리면서 편하게 작업할 수 있는 것에 대한 감사함을 느낄 수 있었던 것 같다.
  그리고 컴퓨터공학과를 진학하게 된 이후로부터 항상 궁금했던 점이 이 책을 읽으면서 해소되었다. while문과 for문.. 너네 둘은 왜 똑같은 기능을 하면서 둘다 존재하는 것인가?라는 생각은 내가 근 3년동안 가지고 있던 의문점같다. 그러면서 한번도 쳐본적은 없었다.
  작동하니까 사용하고 역사에 대해서 알아보지 않았기 떄문이다. 쓰면서도 분명히 for문이 훨씬 이해하기 쉽다라는 감각은 느꼈던 것 같다. 책 내용에도 나와있지만, while문이 나오고나서 그 코드들을 한군데 모아 관리하는 과정에서 for문이 나왔다는 것을 알 수 있어 내 3년간의 작은 고민이
  해결된 것 같아 속이 시원했다. 앞으로도 계속 읽어봐야하겠지만, 이 책은 내가 당연하게 사용하던 기술들에 대해서 왜 이 기술이나 문법들이 어떻게 나오게 되었는지 알려주는 책이라 본인이 사용하고 있는 언어에 대한 불만이 조금이라도 있는 프로그래머라면 쥐어주고싶은 책이다.
