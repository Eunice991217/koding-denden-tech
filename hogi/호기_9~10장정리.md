# 9장_컨테이너와 문자열

처음에는 배열과 연결 리스트를 비교하고 있다.

배열과 연결리스트는 성능 차이가 서로 상이하지만 사람들은 연결 리스트를 선호한다.

이 부분은 연결리스트가 성능적으로 우수하다 라기보다는

연결리스트가 제공해주는 api가 뛰어나기 때문이라 생각한다.

이 처럼 여러가지 컨테이너들을 설명한다.

여기서 컨테이너는 트리, 맵, 리스트 등등 을 가리킨다.

어떤 컨테이너가 가장 좋을까?

완벽한 컨테이너는 없다. 모두 장단점이 존재하고 우리 서비스의 맞는 컨테이너를 고르는 것이 중요하다.

현재 0.01초가 걸리는 로직을 0.005초로 줄인다고 사용자가 만족할까?

내 서비스에 지금 필요한 게 뭔지를 찾는 것도 중요한 능력인 것 같다.

그 이후에는 문자가 어떻게 저장되는 지를 다루고 있다.

이 부분은 가볍게 읽으면 좋을 것 같다.

# 10장_병행 처리

### 협력적 멀티태스크

- 하나의 작업이 완료 되었을 때 자발적으로 변경
- 서로의 신뢰관계를 바탕으로 지속됨
- 만약 하나가 버그로 인해 무한 로딩이 되면 전체가 뒤짐

### 선점적 멀티태스크

- 일정 시간에 교대
- 다른 프로그램이 강제적으로 시간이 되면 중단시킴

### 경합 상태

1. 두 가지의 처리가 변수를 공유하고 있다. → 공유
2. 적어도 하나의 처리가 그 변수를 변경한다. → 변경
3. 한쪽 처리가 마무리 되기 전에 다른 한 쪽이 끼어들 가능성이 있다. →끼어듬

이 3가지 중 하나라도 제거할 수 있다면 경합 상태는 발생하지 않는다.

때문에

- 공유하지 않음
- 변경하지 않음
- 끼어들지 않음

이렇게 3가지의 키워드로 된 여러가지 방법을 사용하며 경합 상태를 막고 있다.

락을 잘 걸어야 경합 상태가 일어나지 않음 ㅇㅇ

그럼 락의 발전 과정을 살펴볼까?

### **1. synchronized 사용**

synchronized 를 사용해서 끼어들면 안되는 경우에 락을 박아버린다.

하지만 이건 개발자가 일일히 해줘야댐..

귀찮기도 하고 놓치면..? 어후;

쫌 더 편한 방법이 없을까?

### 2. 트랜잭션 메모리 사용

일반적으로 우리가 알고 있는 데이터베이스 트랜잭션과 비슷하다.

현재 상황을 복사하여 별도의 상황을 만들고 그것을 작업한 후 성공적이라면 반영한다.

근데 이 과정에서 다른 쓰기가 겹친다면?

내가 별도 상황을 조작후 반영하려고 할 때 현재 상태가 변경되어 있다면

내가 만든 별도 상황을 날리고 현재 상태를 다시 복사하여 다시 로직을 실행한다.

이처럼 별도의 조작없이도 락 처리가 가능하다.

하지만 많은 쓰기 작업이 생긴다면 성능이 나빠질 수 있다.

---

# 생각 정리

9, 10장을 읽으며 `‘정답은 없다.'` 라는 생각을 했다.

수 많은 컨테이너들이 있지만 각자의 장단점이 있고 이것만 써! 라고 하기엔 무리가 있다.

병행 처리도 여러가지 방법이 있지만 정답은 없다.

우테코 크루들과도 개발에 대해 토론하다 항상 결론은 `정답은 없지..` 로 귀결 된다.

각각의 장단점이 있고 지금 내 상황에 무엇이 맞는 지를 고르는 것 또한 개발자의 실력중 하나라고 생각한다.

모든 것은 트레이드 오프고, 이게 개발의 매력이지 않을까..?

결국 내가 잘 선택하기 위해서는 모든 것을 `잘` 알아야 된다.

최고의 하나를 공부하는 것이 아니라 최고의 하나를 만들기 위해 모든 걸 공부해야 된다.

이래서 개발자가 평생 공부해야 되는 거겠지..

어휴..
