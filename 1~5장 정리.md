# 1장 효율적인 언어 배우기

### 1.1 비교를 통한 배움

언어를 학습하게 되면 느끼게 되는 점이 있다. 기존에 학습했던 언어와 새로 학습하는 언어 사이의 다른점과 공통점을 비교하게 된다는 점이다. 언어마다 각자의 규칙을 정해 사용한다.

예를 들면 C언어에서는 0을 거짓으로 1을 참으로 사용할 수 있다. 하지만 Ruby라는 언어에서 0은 참으로 받아들여진다. 또한 Java에서 0은 정수형으로만 사용되기 때문에 조건식에 0을 사용하면 컴파일 에러가 발생한다.

### 1.2 역사를 통한 배움

언어를 학습할 때는 언어를 만든 설계자가 어떤 문제를 해결하기 위해 이 언어를 만들었는지를 고민해볼 필요가 있다.
언어는 생각을 표현하는 수단 중 하나일 뿐이다. 특정 언어에 종속적일 필요가 없다.
언어에 의존적이지 않도록 보편적인 지식을 습득하는 것이 중요하다. 5년 후, 10년 후에 자신이 어떤 언어를 사용해 개발하고 있을지는 아무도 모르는 일이다.

### 1.3 정리

이 책에서는 특정 언어에 국한된 지식이 아니라 보다 보편적인 지식을 습득할 수 있도록 하고있다. 이를 위해 '비교를 통한 배움'과 '역사를 통한 배움'이라는 2가지 방식을 사용해 설명한다.


# 2장 프로그래밍 언어를 조감하다

### 2.1 프로그래밍 언어 탄생의 역사

프로그래밍 언어는 어떻게 탄생했을까? 1946년에 ```ENIAC```(Electronic Numerical Integrator and Computer)이 발명되었다. 이 컴퓨터는 무엇을 계산할지에 따라 프로그램을 변경할 수 있게 만들어졌다. ENIAC은 케이블을 여기저기 연결하는 것으로 프로그래밍했다. 

이후 1949년 ```EDSAC```(Electronic Delay Storage Automatic Calculator)이 등장했다. 이것은 테이프에 구멍을 뚫어서 데이터를 표현하고 그것을 컴퓨터가 읽어 들이도록 한 구조였다. 프로그래밍이 조금 쉬워졌지만 사람이 프로그램을 읽거나 쓰는 것은 여전히 어려웠다.

1954년, 드디어 우리가 사용하는 프로그래밍과 유사한 언어인 ```FOTRAN```이 탄생했다. 이 언어는 'x 곱하기 y 더하기 z'를 x * y + z라고 표현할 수 있게 만들어 줬다.

### 2.2 프로그래밍 언어 탄생의 목적

프로그램은 어떤 것을 편하게 하기 위해 고안된 것이다. 프로그래머로써 가져야 할 3대 미덕으로 '나태, 조바심, 자만감' 이라고 표현한 것도 이와 비슷한 이유에서 나온다. 이 중 나태란 당장에 눈에 보이는 편리함을 요구하는 것이 아니라 앞날을 생각해 가장 편한 방법을 선택하는 것이다.

프로그래밍 언어의 목적은 '편리함'이라고 말했지만, 편리함은 사람에 따라 다르게 생각할 수 있기 때문에 다양한 프로그래밍 언어가 탄생한 것이다.

예를 들어 C++은 빠른 실행 속도를 중시하겠다는 목적에서 탄생했다. 하지만 이는 언어 사양이 더 복잡해졌다.
반면에 Scheme은 언어 사양을 쉽게 파악할 수 있는데 중점을 두고 있는 언어다. Python은 사람이 쓴 코드를 쉽게 해석할 수 있는데 중점을 두고있다. 이처럼 언어마다 중요하게 생각하는 기준이 있고 그 목적에 따라 프로그래밍 언어의 성격도 달라진다.

### 2.3 정리

프로그래밍 언어는 사람을 편하게 하기 위해 만들어졌다. 하지만 무엇이 편한지는 언어에 따라 다르다.
떄문에 자신이 구현하는 프로그램에 따라 적절하게 좋은 도구를 현명하게 선택하여 적재적소에 사용해야 한다.



# 3장 문법의 탄생

### 3.1 문법이란?

일반적인 수식에서 1 + 2 * 3을 계산하면 2 * 3이 먼저 계산된다. 이런 것 또한 하나의 문법이다. 
언어 설계자가 정한 규칙이 바로 문법이다. 문법은 언어에 따라 다르다. 예를 들어 C언어에서는 '='가 연산자이며, 일반적인 가감승제(사칙연산)와 틀리게 '우결합성 연산자'이다. 그래서 x=y=1이라고 쓰여있으면 x=(y=1) 처럼 해석된다.


### 3.2 스택 머신과 FORTH

FORTH란 1958년 개발된 문법이 거의 존재하지 않는 언어다.
FORTH에서 계산할 때는 스택을 사용한다고 생각하면 편하다.

'1과 2를 더한다'는 코드를 FORTH에서는 '1 2 +'라고 쓴다. 
'1과 2를 더한 것에 3을 곱하다'는 '1 2 + 3 *'이처럼 표현된다.

Java, Python, Ruby 등은 스택 머신(Stack machine) 형의 VM을 사용하고 있다. 앞 언어들로 프로그램을 짜면 그 프로그램은 내부적으로 FORTH와 같은 프로그램으로 변환(컴파일)되어 동작한다.

### 3.3 구문 트리와 LISP

LISP라는 언어는 '하나의 구역을 펴한하기 위해 항상 괄호를 사용하자'라는 생각으로 탄생했다.
LISP는 '1과 2를 더한다'를 '+ 1 2'라고 표현하고
'1과 2를 더한 것에 3을 곱하다'는 '(* (+ 1 2) 3)'과 같이 표현한다.

즉, 이 2가지 언어의 생김새는 크게 다르지만 동일한 구조를 사용해서 '하고자 하는 것'을 표현한다.

### 3.4 중위 표기법

LISP는 전위 표기법을 사용하고, FORTH는 후위 표기법을 사용한다. 일반적으로 사람들은 중위 표기법을 익숙하다고 느낀다.
이 3가지 방법은 식을 표현하기 위한 약속에 불과하다. 

### 3.5 정리

'1더하기 2에 3을 곱한다'는 똑같은 처리도, 언어에 따라 표현방법이 다르다. 이들 언어에 차이가 생긴 것은 규칙이 달랐기 때문이다. 이것이 문법이다.

모순 없이 해석할 수 있는 문법을 만드는 것은 어려운 작업이다. 나중에 새로운 문법과 충돌이 발생할 수 있기 때문이다. 때문에 현실의 프로그래밍 언어에는 이해하기 어려운 작성법이 여전히 존재하는 것이다.


# 4장 처리 흐름 제어

### 4.1 구조화 프로그래밍의 탄생

3장에서 문법의 개념에 대해 알아봤다. 이번 장에서는 if와 while문에 대해 알아보자
이 두 구문은 코드 구조를 알기 쉽게 하기 위해 도입되었다.

### 4.2 if가 탄생하기 전

if는 왜 있는 걸까? 어셈블리어에는 if 문이 없다. 어셈블리어에서는 jne를 통해 점프시키는 것으로 if문을 사용한다.
이 와 같이 '조건을 만족하면 점프'라는 명령은 EDSAC에도 있었다.

else는 왜 탄생했을까? else가 없어도 충분히 프로그램을 짤 수 있다. c언어에서는 else를 대신해 goto라는 기능을 사용하기도 한다. 하지만 현재 goto보다는 else를 많이 사용한다.

else를 사용하면 코드의 가독성이 증가한다. '조건이 참인 경우와 거짓인 경우 처리 흐름을 분배한다'는 패턴은 프로그래밍에 빈번히 사용한다. 때문에 읽기 편하도록 나오게 된것이다.

### 4.3 while, 반복되는 if를 읽기 쉽게 표현

while문은 '조건을 만족하는 동안 블록 안의 내용을 반복하여 실행하기 위해 만들어졌다.
while문이 가져온 편리함은 '새로운 것'이 아니라 '읽기 쉽게 함', '쓰기 쉽게 함'이다. 

### 4.4 for, 수치를 증가시키는 while을 읽기 쉽게 표현

흔히들 while이 있으면 for는 필요 없다고 생각한다. 실제로도 for문으로 할 수 있는 것은 while 문으로 표현이 가능하다. while문은 변수 선언, 조건문, 증감 연산자가 3가지 부분으로 분산되어버린다. 때문에 코드를 이해하기 위해서는 3군데를 모두 찾아야한다. for문은 이를 개선하기 위해 한 곳에서 3가지 일을 정의할 수 있다. 바로 이점이 for문을 사용하는 이유이다.

그렇다면 많이 사용하는 foreach는 무엇때문에 탄생했을까? while은 조건식으로 반복을 제어한다. for문은 횟수로 반복을 제어한다. foreach 구문은 처리 대상으로 반복을 제어한다.
foreachsms '어떤 대상의 요소 전부에 어떤 처리를 한다'는 코드를 쉽게 쓰기위해 만들어졌다.

### 4.5 정리

이번 장에서는 if, while, for문 등의 처리 흐름을 제어하기 위한 문법에 대해 배웠다. 이 문법들을 사용하지 않아도 프로그램을 짤 수 있다. 하지만 알기 쉬운 코드를 구성하기 위해서는 사용하는 것이 이롭다.

# 5장 함수

### 5.1 함수의 역할

5장에서는 함수에 대해 이해해보려고 한다. 한수는 '코드의 일부를 한 덩어리로 잘라내어 그것에 이름을 붙이는 기능'이다. 

함수를 사용할 때 생기는 이점

1. 가독성 증가 : 코드 양이 많아지면 그 코드가 어떤 역할을 하는지 알아보기 쉽지 않다. 하지만 함수를 사용하면 해결이 가능하다.
2. 구조의 단순화 : 기능들을 함수 단위로 쪼개 사용하면 함수를 사용하는 입장에서 그 함수가 어떤식으로 작업을 수행하는지 이해하지 않아도 된다.
3. 재사용성 증가 : 함수로 정의해 사용하면 다른 곳에서 함수를 호출해 재사용 할 수 있다.
4. 유지보수성 증가 : 오류가 발생했을 때 어느 부분에서 발생했는지 알기 쉽다. 그 함수만 갈아끼우면 잘 동작한다.

### 5.2 돌아가는 명령

앞에서 이해했던 if, while, for문은 전부 goto문으로 구현됐다. 하지만 소스 코드를 재사용하기 위해서는 goto문 만으로는 구현하기 어렵다. 구현하기 어려운 이유는 '원래 위치로 되돌아가다'라는 기능이 없기 때문이다. 어디에서 점프해 왔는지를 기억하고 로직을 수행 후 다시 되돌다가는 명령을 만나면 되돌아가게 하고 싶다는 것이다.

처음에는 변수에 돌아갈 위치를 저장해 원래 위치로 돌아오는 동작을 호출하는 것으로 구현했었다. 하지만함수를 호출하는 사람이 '점프 목적지가 어디인지', '돌아가는 명령이 있는 곳은 어디인지'를 상호간에 파악해야 했다. 

이후에는 돌아갈 목적지를 기록하는 전용 메모리를 만들어 사용해 호출처가 돌아가는 명령의 위치를 알지 못해도 됐다.

하지만 이 방법에도 문제가 있었다. 2중, 3중으로 함수를 찾아가면 목적지가 덮어 씌워져서 목적지를 잃어버린다는 점이었다. 다음에 나온 방식은 스택을 이용한 방식이다. 스택을 확인하며 돌아가야 하는 최신 위치를 꺼내 사용할 수 있게 되었다.

### 5.3 재귀 호출

재귀 호출은 왜 만들어지게 되었을까? 이는 '어떤 처리를 하고 있는 도중에 동일한 처리를 다른 대상에 대해 실행한다'는 내포(중첩) 형태의 처리이다. 이 책에서 예를 든 것은 배열 내부에 배열이 들어가있을 때 그 내부를 알아보는 방식으로 표현했다. for문만으로 해결하지 못한 문제를 재귀호출을 사용해 해결한다. 또 다른 예시로는 HTML 태그가 있다. 

### 5.4 정리

프로그램의 규모가 커지면 전체적인 구조를 파악하기 어려워진다. 또한 비슷한 로직을 반복해서 사용해야 하는 경우도 생긴다. 함수는 이 문제를 해결하기 위해 탄생했다. 또한 함수를 사용함으로 '재귀 호출'이라는 코딩 기술이 탄생하게 된다. 이는 내포 구조로 된 데이터를 다루기에 적합하다.

