# 11장_객체와 클래스

클래스가 없어도 객체처럼 사용할 수 있는 방법에 대해 기술한다.

모듈, 해쉬, 클로저 등등의 방법을 합치며 클래스 없이 객체를 만든다.

1. 모듈을 만들며 관련성이 있는 애들을 묶음
2. 해쉬를 사용하여 여러개의 객체를 만들 수 있도록 함
→ 공유되는 변수와 함수를 묶고, 개별적으로 사용되는 변수와 함수를 묶는다.
→ 공유된 것은 하나의 프로토타입으로, 공유 되지 않는 것은 각각의 개별 객체(?) 로 나눈다.
3. 클로저를 사용하여 상태 정보를 가질 수 있게 한다.

이와 같은 내용을 읽으며 클래스가 어째서 나왔는지 알 수 있었다.

### 클래스의 최초 목적

1. 결합체를 만드는 생성기
2. 어떤 조작이 가능한지 알려주는 안내서
3. 코드를 재사용

이러한 이유로써 클래스를 만들었다.

# 12장_상속

이 책에서는 상속에 대한 내용을 다루고 있다.

**이번 장에서는 정리라기 보단 내가 생각하는 상속에 대해 말해보고 싶다.**

상속이라는 목적 자체는 좋다.

코드의 재사용성을 높이고, 비슷한 애들끼리 묶을 수 있으니까

하지만 상속이라는 방식은 장점보다는 단점이 많다고 생각한다.

### 책에서 말하는 상속의 뎁스가 깊어진다면?

깊이가 있는 상속을 한 시점부터 코드를 읽기가 힘들어 진다.

상속 이라는 개념이 보통 가장 마지막 자식을 사용하게 되는데

만약 상속의 뎁스가 깊어진다면?

예를 들어보자

Car라는 부모의 자식으로 Auto, Stick

Auto의 자식으로 승용차, Suv

마지막으로 승용차의 자식으로 아반떼(꼬상 차) 가 있다고 생각해보자

각각의 부모들한테는 또 각자의 메서드 들이 있을 것이다.

`Avante avante = new Avante();`

`avante.함수1();`

여기서 사용하는 함수1 이 어디서 나온건지 알겠는가?

Car 꺼야? Auto꺼야? 승용차꺼야? 아반떼꺼야?

확인하려면 하나씩 타고타고 확인을 해봐야 한다.

그리고 위와 같은 구조를 파악하는 데에도 모든 코드를 다 읽어봐야한다.

### 캡슐화 문제

사실 상속을 사용하지 말라는 가장 큰 이유이다.

**캡슐화가 뭔데 씹덕아.**

→ 내가 다른 객체의 내부 구현을 몰라야 된다는 소리다.

상속을 받은 자식은 부모의 내부 구현을 다 알고 있다.

즉, 상속을 받은 시점부터 캡슐화는 깨지게 된다.

캡슐화는 객체 지향의 특징 중 가장 강력한 무기 중 하나다.

하지만 상속을 사용하기만 했는데도 이 무기가 없어진다면 쓰는게 맞는가..?

### 개인적으로 통일화가 어려운 것 같음

이건 그냥 상속을 쓰면서 느꼈던 개인적인 의견인데

이번 체스 미션을 하면서 Piece라는 움직이는 말들을 부모로 만들고

그 아래 king, queen, pawn 등등 자식들을 만들었음
다른 말들은 움직이는 경로에 상대말이 있으면 잡아 먹으면 됨

근데 pawn 이새끼는 움직이는 경로와 공격하는 경로가 다름

즉, 비슷하다 생각해서 묶었는데 다른 놈들이 꼭 하나씩 있음

사실 개발이라는게 전부 다 내가 생각한 레인지 안에서 컨트롤하는 건 너무 이상적인 말임

그럼 이런 경우 일단 상속을 써서 개발을 했으니 어거지로 라도 pawn을 끼워맞추는게 맞나?

사실 이럴꺼면 안쓰는 게 맞지 않나? 라는 생각도 들었다.

상속은 코드 재사용이라는 큰 장점이 있다.

하지만 상속의 완벽한 틀을 맞추는 것은 어렵다는게 개인적인 생각이다.

~~개인적으로 ‘개발할때 상속을 절대 쓰지 않는다..’라고 미션하며 다짐했다.~~
