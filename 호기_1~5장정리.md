# 1장_효율적으로 언어 배우기

- 규칙은 언어마다 다르다.
    
    → 지금 우리가 사용하고 있는 언어의 규칙은 절대적인 것이 아니다.
    
    `단지, 지금은 이렇게 하는 것이 보다 더 수월해 보여요! 일단 이렇게 합시다!`
    
    이런 약속일 뿐이다.
    
- 1장은 이 책의 목적에 대해 설명한다.
사실 프로그래밍 언어는 변화의 속도가 빠르고 어떤 언어가 뜰지 누구도 예측할 수 없다.
때문에 `어떤 언어를 공부할까요..?` 와 같은 질문은 타당하지 않다.
    
    특정 언어를 다루는 것이 아닌 보다 보편적인 지식을 습득하는 것을 목표한다.
    

# 2장_프로그래밍 언어를 관찰하다

## 프로그래머의 3대 미덕

나태, 조바심, 자만심

- 나태 - 전체 에너지 소비를 줄이기 위해 대부분의 능력을 집중하는 기질.
    - 노동력을 줄이기 위해 편리함 프로그램 만들기
    - 일일히 대답하는 것이 귀찮아 문서를 만들기
- 조바심 - 프로그램이 느린 것을 용납하지 않는 것
- 자만심 - 틀린 것을 방치하지 않음

결국 이 3가지를 관통하는 키워드는 `편하게 하다.` 이다.

그렇다면 언어는 왜 이렇게 많을까? 가장 편한 언어 하나 쓰면 되지 않을까?

그 이유는 사람마다 편하다고 생각하는 기준이 다르다.

누구는 빠른 프로그램이, 누구는 읽기 쉬운 프로그램이 `편한` 프로그램이라고 생각한다.

C++은 빠르지만 사양이 크고, Python은 읽기 쉽지만 느리다.
때문에 **왜 python은 이렇게 느리냐 ㅅㅂ;;** 라고 하는 것은 유익하지 못한 논쟁이다.

프로그래밍 언어는 도구이다.

우리가 어떤 목적으로 사용하는지에 따라 필요한 언어가 달라질 수 있다.

때문에 `이 언어가 유행이라니까 이거 써야지~` 와 같은 이유는 생산성과는 전혀 관련이 없다.

다른 사람에게 혹하지 말고, 나만의 이유를 찾아 좋은 도구를 선택하자.

# 3장_문법의 탄생

3장은 전체적으로 문법의 탄생과정을 서술하고 있다.

과거 FORTH, LISP와 같은 언어들은 수식 계산 과정을 전위, 후위 연산으로 해결했다.

FORTRAN은 우리가 쉽게 만날 수 있는 중위연산을 받아 구문 해석기를 통해 내부적으로 변환을 시도해 전위, 후위 연산으로 바꾼다.

이와 같은 이유로 FORTRAN이 많은 사랑을 받게 되었다.

대부분 프로그래밍 언어의 목표는 FORTRAN과 같이 `다가가기 쉬운 작성법` 이다.

하지만 이 과정을 모순 없이 만들어 내는 것은 쉽지 않다.

특히 새로나온 언어들이 과거의 기존 문법과 충돌이 나지 않게 만드는 것은 더 어렵다.

때문에 가끔 `이거 왜 이렇게 해야됨..?` 과 같은 이해하기 어려운 작성법들이 있는게 아닐까..?

# 4장_처리 흐름 제어

컴파일을 해서 어셈블리어로 변환하고 어셈블 해서 기계어로 변환한다. 그 후 링크해서 파일을 연결하여 실행하는이 과정을 `컴파일` 이라고 부른다.

우리는 흔히 if-else 구문을 사용한다. 그렇다면 어셈블리어 에서도 if-else가 있을까?

그렇지 않다. 어셈블리어는 jump라는 명령어를 통해 조건이 맞지 않는 다면 그 줄로 뛰어 넘는다.

완벽한 절차지향 느낌이랄까..?

이 얘기를 왜 했을까? 라고 생각 해봤을 때

결국 `가독성` 이라는 이야기를 하고싶지 않았을까? 생각한다.

if-else를 사용하지 않고도 분기를 처리할 수 있지만 가독성을 생각한다면 if-else구문이 훨씬 이해하기 쉽다.

이는 while문도 같다. while문 없이는 반복을 못하나? 아니다 goto를 사용하면 가능하다.

`즉, 새로운 것을 만들어 낸 것이 아니라 읽기 쉽게 한 것이다.`

개인적으로 우리가 앞으로 개발을 할때 무엇보다 중요한 것은 `읽기 쉬움` 이 아닐까?

# 5장_함수

함수의 가장 큰 장점이 뭘까?

나는 재사용성이라 생각한다. 또한 코드상의 재사용성은 가져다 주는 의미가 크다.

정수기를 100개에서 200개로 늘린다면 이미 만드는 설계도가 다 있어 빠르긴 하겠지만 어쨌든 100를 추가 설치하는 리소스가 들어간다.

하지만 코드는 한번 작성을 해놓는다면 100번이든 200번이든 그냥 불러다가 쓰면된다.

또한 함수 호출에 대한 것을 최종적으로 스택을 활용해 푸는 과정을 담고있다.

스택에 함수 호출 후 돌아갈 곳에 대한 주소를 가짐으로써 함수를 구현할 수 있다.

---

# 나의 생각

누군가 나에게 유지보수성이 좋은 코드가 뭐야? 라고 한다면 망설임 없이 `가독성이 좋은 코드` 라고 답할 수 있다.

5장까지의 책을 읽으며 필자가 말하고 싶어 하는 것은 `읽기 편한 코드` 라고 생각했다.     



if-else 없이도 분기 처리 할 수 있지 근데 왜 써?
→ 가독성을 위해

while, for 없이도 반복 할 수 있어 근데 왜 써?
→가독성을 위해

함수 없이도 코드를 묶을 수 있어 근데 왜 써?

→ 가독성을 위해, 재사용성을 위해

2장에서 말하듯이 언어는 `편하게 하기 위함`  을 위해 탄생했다.

그럼 가장 편한 코드는 뭘까?

요즘 느끼는 것이지만 우리가 지향하는 클린 코드, 객체 지향 과 같은 내용을 살펴보면

결론적으로는 `읽기 쉬운 코드` 를 작성하기 위해 지키는 원칙들이다.

`읽기 쉬운 코드`를 위해 과거 부터 언어가 이렇게 발전해 왔구나 라는 생각이 드는 내용이었다.
