# 6장 에러 처리

### 예외 처리 방식

1. 반환값으로 알린다.

   이 방식은 실패 했을 때의 반환값을 정해두고 if문을 사용해 예외를 처리하는 방식이다.

   문제점
    1. 실패를 놓칠 수 있다.
    2. 에러 처리 때문에 코드를 해석하기 어렵다.

2. 실패하면 점프한다.

   이 방법이 발전해서 현재의 '예외 처리'가 되었다.

   UNIVAC 1 -> COBOL -> PL/I 에 거쳐 발전한 모습을 확인했다.

   문제점
    1. 짝을 이루는 처리를 하기 어렵다.
    2. 함수가 어떤 예외를 던질지 그 함수의 코드를 확인해도 알 수 없다.

   > 2-2 문제점에 내부 코드를 확인해야 예외를 알 수 있는 거면 의존과 관련이 있나?

3. Java, C++, Python 에서의 예외 처리 방식

   Java 등의 구문에서는 '실패할 것 같은 코드를 미리 try{}로 묶어둔 후 실패했을 때 처리를 쓰는'형식이다.

   > 차이가 뭘까? 예외를 바깥으로 던진다는 것이 차이점인건가?


### finally

finally 는 어쩌다 생겨났을까?

짝이 되는 처리를 반드시 실행해야 하는데 return 이 여러 곳에 존재한다면 각각의 return 앞에 짝이 되는 처리가 모두 들어가야 한다.
이를 해결하기 위해 탄생했다. 예를 들면 lock, unlock 이 있다.


### 예외 전파

예외를 사용하는 다양한 언어에서의 예외 처리에서는 예외가 호출처로 전파된다.

예외 전파의 문제점 : 함수의 소스 코드를 봐도 어떤 예외를 발생시키는 지 모른다.

Java 에서는 throw를 통해 검사 예외를 제공한다. 하지만 불편하기 때문에 다른 언어에서는 잘 채택되지 않는다.

---

# 7장 이름과 스코프

이번 장에서는 변수가 생겨나게 된 계기와 스코프에 대해 설명하고 있다.

### 변수

변수가 생겨나게 된 계기는 알고 있다시피 메모리 주소와 같이 사람이 이해하기 어려운 방식으로 값을 호출하기 보다는 
이름을 매칭해 편하게 값을 사용하기 위해 나왔다.

하지만, 초기에 나온 변수는 한 공간에서 관리되다보니 변수 관리가 쉽지않았다.

### 스코프

위에서 발생한 문제를 해결하기 위해 스코프라는 개념이 탄생하게 된다. 
스코프(Scope)란 유효한 범위를 의미한다. 프로그램 전체가 아닌 변수의 유효범위를 줄여 관리가 편하게 한다.

- 동적 스코프

  - 동적 스코프의 범위는 함수 내부다. 
  - 함수 밖에서 선언한 변수와 함수 내부에서 선언한 변수를 구분해주는 기능을 한다. 
  - 동적 스코프의 문제점으로는 함수 내부에서 다른 함수를 호출한 경우에는 변수를 공유한다는 점이다.

- 정적 스코프

  - 정적 스코프의 범위 또한 함수 내부다. 
  - 하지만 동적 스코프와 다른 점은 함수에 따라 새로운 대응표를 만들어 준다는 점이다.
  - 내포 함수가 있는 경우 보이기로는 가까이 있는 변수에 접근할 것같지만 내포 함수에 변수가 없으면 전역 변수를 가져온다.
  - 외부 스코프에 접근할 수 없다. -> Python, Ruby 의 해결법
    > Ruby와 Python의 문법이 비슷한 이유는 Ruby가 python의 영향을 받은 언어이기 때문

### 정리

동적 스코프는 많이 사용되지는 않지만 개념적으로 알고있으면 좋을 것 같다. 
개념적으로 다른 곳에서 비슷하게 사용되는 경우가 있는 것 같다.
try/catch 의 경우 함수 내부에서 던진 예외를 받아서 사용한다는 점이 비슷하다.

객체 지향에서 private 으로 선언해 접근을 제한하는 것 또한 스코프와 닮았다. 
private 와 protected 를 비교해 범위가 넓어지는 것이 동적 스코프와 비슷하다.

> 클래스를 스코프와 비교하는 이유가 뭘까?

> 싱글톤(singleton)패턴을 전역 변수의 대용으로 사용하지 말자
> -> 클래스를 하나만 만드는 것과 변수를 하나만 만드는 것은 다르다. 

---

<br/><br/><br/><br/><br/><br/><br/><br/><br/>


