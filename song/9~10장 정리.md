# 9장 컨테이너와 문자열

### 컨테이너란?

컨테이너란 다양한 형태로 무언가를 저장하는 저장소라고 생각된다.
컨테이너는 언어마다 다양한 형태로 사용되고 있다.

### 배열과 연결리스트

배열은 데이터를 순서대로 저장하는 방식이고 연결리스트는 다음 저장된 데이터 위치를 함께 가지고 있다.

|      /      |    배열    | 연결 리스트 |
|:-----------:|:--------:|:------:|
|    임의 접근    |   O(1)   |  O(n)  | 
|  맨 뒤 원소 삽입  |   O(1)   |  O(1)  | 
|  중간 원소 삽입   |   O(n)   |  O(1)  | 


연결 리스트 장단점
- 중간에 원소를 삽입할 때와 삭제할 때의 시간이 적게 걸린다. -> 장점
- n번째 항목에 접근할 때 처음부터 접근하며 찾아야 하기 때문에 오래걸린다 -> 단점

Java, Python, Ruby 등의 대부분의 언어는 배열이 가장 기본적인 컨데이너이다. 
하지만 LISP, Scheme, Haskell 등의 언어에서는 연결리스트가 기본적인 컨테이너로 제공된다.

### 사전, 해쉬, 연상 배열

사전(Dictionary), 해쉬(Hash), 연상 배열 등으로 불리는 것들이 있다.

- 해쉬 테이블

  해쉬 테이블은 문자열을 인수로 받아서 정수로 반환하는 '해쉬 함수'를 사용해서 문자열과 값의 대응 관계를 표한하는 방법이다.

  값을 꺼낼 때의 시간 복잡도 : O(1)

- 트리

  트리는 주로 완전 이진트리를 이용해 구현하는 방식이다.
  
  값을 꺼낼 때의 시간 복잡도 : O(log n)

### 문자열 

- 문자열의 진화 과정

  모스부호 -> 보 코드 -> EDSAC 문자 코드 -> ASCII와 EBCDIC -> Unicode

문자열이란 문자가 정렬되어 있는 것을 말한다. 하지만  언어에 따라 표현 방식이 다르다.

C언어를 제외한 Pascal, Java, Ruby, Python 등의 언어는 문자열 자신의 길이를 포함하고 있다.

C언어는 NUL(\0)을 사용해 문자열의 끝을 파악한다.

Java의 문자열은 다른 문자열과 다르게 char 형이 16비트로 정해져있다.


# 10장 병행 처리

### 병행 처리의 2가지 방법

- 협력적 멀티테스크
    
  주로 비선점적 멀티테스킹이라고 불리며 처리가 수행 중일때 다른 처리가 들어오게 되면 
  첫번째 들어온 처리가 마무리 되면 다음 처리를 수행한다.

- 선점적 멀티테스크

  일정 시간을 정해 처리를 교대적으로 수행하는 방식이다.이 방식은 스케줄러를 사용해 관리한다.

### 경합 상태(Race condition) : 스레드 세이프가 아니다

위에서 설명한 선점적 멀티테스크 방식에는 큰 문제가 있다.
바로 일 처리 중간에 다른 일을 수행할 때 비정상적인 처리가 일어날 가능성이 있다는 점이다.

경합 상태 3가지 조건
1. 2가지 처리가 변수를 공유하고 있다.
2. 적어도 하나의 처리가 그 변수를 변경한다.
3. 한쪽 처리가 한 단락 마무리 되기 전에, 다른 한쪽의 처리가 끼어들 가능성이 있다.

경합 상태가 발생하지 않기 위해서는 위 3가지 조건 중 한가지를 제거해야 한다.

### 프로세스 vs 쓰레드

이 두가지 개념은 조건 3가지 중 1번을 제거하기 위해 나타났다.

프로세(Process)란? 메모리에 올라와 실행되고 있는 프로그램의 인스턴스를 말한다.
프로세스끼리는 메모리를 공유하지 않는다. 

하지만 병행처리를 위해 여러 프로세스를 구동하는 것은 많은 오버헤드를 발생시킨다. 또한 프로세스끼리 통신이 어렵다는 단점도 있다.

위 문제를 해결하기 위해 쓰레드가 탄생했다. 
쓰레드(Thread)란? 하나의 프로세스 내부에서 실행되는 여러 흐름의 단위를 말한다. 
stack을 할당받아 메모리를 공유한다.

- 엑터 모델

  병행 처리에서 정보를 교환하는 또다른 방식으로 '메모리를 공유하는 방식'이 아닌 '메시지를 보낸다'라는 방식이다.
  
  이 방식은 비동기로 처리된다. 처리를 요청하고 자신의 일을 처리하다가 완료 메시지를 받으면 끝났다고 인식하는 방식이다.

### 변경하지 않는다.

경합 조건의 2번째 조건인 '적어도 하나의 처리가 그 변수를 변경한다'를 제거하는 방식도 존재한다.

이 방식은 '일부 변수를 변경할 수 없게 한다'를 제공하는 언어들에서 사용한다.

1. C++ : const를 붙이면 변경할 수 없는 변수가 된다.
2. Scala : var과 다르게 val로 선언하면 변경할 수 없다.
3. Java : Immutable 패턴이 많이 사용된다. private 필드를 만들어 getter만 사용하고 setter를 사용하지 않아 읽는 것만 가능하도록 한다.

> java 에서 setter 를 만들지 않는다고 immutable 하다고 할 수 있나?
> 
> 아니라고 생각한다. 그렇다면 immutable 하게 만들기 위해서는 어떻게 해야할까?

### 끼어들지 않는다.

경합 상태의 3번째 조건인 '한 쪽의 처리가 한 단락 마무리 되기 전에 다른 한 쪽의 처리가 끼어들 가능성이 있다'를 방지하기 위한 방식은 무엇이 있을까?

그 방법 중 하나가, 파이버(fiber)나 코루틴(coroutine), 그린 스레드(Green thread)라고 불리는 방식이다.

쓰레드가 선점성을 가지고 끼어드는 원인을 해결하기 위해 비선점 방식인 협력적 스레드를 만든다는 생각이다.

- 락, 뮤텍스, 세마포어
  
  위 세가지 방식은 '다른 쓰레드가 끼어들면 곤란한 처리를 하고있다'라고 명시해 놓는 방식이다.

  Java 언어 사용자는 자신이 직접 고생하지 않고 'synchronized 블록'으로 감싸기만 하면 손쉽게 락을 걸 수 있다.

> 3가지 방식의 차이점
> 
> 뮤텍스와 세마포어는 락의 방식이다?
> 
> 뮤텍스 : 뮤텍스의 경우엔 Locking 메커니즘으로 오직 하나의 스레드만이 동일 시점에 뮤텍스를 얻어 임계 구역(Critical Section)에 접근할 수 있다. 
> 그리고 획득(Lock) 또는 해제(Unlock)의 주체는 동일해야 한다.
> 
> 세마포어 : 표현형은 정수로 표현하며 획득(Lock) 또는 해제(Unlock)가 아닌 값을 올리고 내리는 방식으로 사용한다.
> 하나 이상의 스레드가 공유자원에 접근하도록 할 수 있다. 



- 락의 문제점

  1. 교착 상태(Deadlock)가 발생한다 : x와 y가 둘다 서로가 원하는 자원을 소지하고 락을 걸었을 때 발생한다.
  2. 합성할 수 없다 : 리스트 x에서 값을 꺼내 리스트 y에 넣을 때 빼낸 값을 넣기 전 애매한 상황이 발생하는데 이 때 다른 작업이 끼어들면 문제가 발생할 수 있다.

### 트렌잭션(Transaction)

위 2번 문제를 해결하기 위해 트랜잭션 메모리라는 접근법이 생겼다.

이 방식은 x나 y를 직접 변경하는 것이 아니라 일시적으로 별도의 버전을 만들어 변경하고 하나의 묶음 처리가 끝나면 반영하는 것이 포인트다.

별도의 버전에서 처리를 수행하다 다른 처리가 들어와 값이 변경되면 그 버전을 버리고 다시 처음부터 수행한다.

- 하드웨어로 구현 : 상업적으로 성공하지 못했다.
- 소프트웨어로 구현 : 여러 언어에서 소프트웨어 트랜잭션 메모리 기능이 탑제되었다.


<br/><br/><br/><br/><br/><br/><br/><br/><br/>




